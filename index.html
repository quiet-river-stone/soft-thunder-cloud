<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Modular Hearts Layout</title>

  <link rel="stylesheet" href="styles.css">
</head>
<body>

<!-- Password gate overlay -->
<div id="pw-overlay" role="dialog" aria-modal="true">
  <div id="pw-box">
    <h3>Enter password to view</h3>
    <div>Type the access password to continue.</div>
    <input id="pw-input" type="password" placeholder="Password" aria-label="Password" />
    <button id="pw-submit">Unlock</button>
    <div id="pw-error" aria-live="polite"></div>
  </div>
</div>

<canvas id="canvas"></canvas>
<div class="container" id="content"></div>

<script type="module" src="main.js"></script>

<script>
  (function(){
    const PASSWORD = 'valentine'; // inline fallback so file:// testing works
    const overlay = document.getElementById('pw-overlay');
    const input = document.getElementById('pw-input');
    const submit = document.getElementById('pw-submit');
    const errorEl = document.getElementById('pw-error');

    function unlock(){
      try{ overlay && overlay.parentNode.removeChild(overlay); }catch(e){}
      try{ sessionStorage.setItem('page_unlocked','1'); }catch(e){}
      try{ window.dispatchEvent(new CustomEvent('pageUnlocked')); }catch(e){}
    }

    function fail(msg){ if(errorEl) errorEl.textContent = msg || 'Incorrect password'; }

    if(submit && input){
      submit.addEventListener('click', ()=>{
        const v = (input.value||'').trim();
        if(v === PASSWORD) unlock(); else fail();
      });

      input.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') submit.click(); });
    }

    if(sessionStorage.getItem && sessionStorage.getItem('page_unlocked') === '1'){
      unlock();
      // continue
    }

    try{
      const qp = new URLSearchParams(location.search).get('pw');
      if(qp){ if(qp === PASSWORD) unlock(); else fail('Invalid URL password'); }
    }catch(e){}
  })();

/* ===============================
   CONFIGURE YOUR CONTENT HERE
================================ */

const contentData = [
  {
    title: "First Box",
    text: "Edit this text directly in the contentData array. Add as many boxes as you want."
  },
  {
    title: "Second Box",
    text: "You can swap this text for an image by using the 'image' property instead."
  },
  {
    title: "Third Box",
    text: "The layout auto-renders based on this configuration."
  }
];

/* ===============================
   RENDER BOXES (Modular)
================================ */

const container = document.getElementById("content");

function renderBoxes(data) {
  container.innerHTML = "";

  data.forEach(item => {
    const box = document.createElement("div");
    box.className = "box";

    if (item.image) {
      const img = document.createElement("img");
      img.src = item.image;
      box.appendChild(img);
    }

    if (item.title) {
      const title = document.createElement("h2");
      title.textContent = item.title;
      box.appendChild(title);
    }

    if (item.text) {
      const text = document.createElement("p");
      text.textContent = item.text;
      box.appendChild(text);
    }

    container.appendChild(box);
  });
}

renderBoxes(contentData);

/* ===============================
   HEART BACKGROUND SYSTEM
================================ */

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let width, height;
let hearts = [];
let droplets = [];

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

class Heart {
  constructor() { this.reset(true); }

  reset(initial = false) {
    this.x = Math.random() * width;
    this.y = initial ? Math.random() * height : -20;
    this.size = 6 + Math.random() * 8;
    this.speed = 0.5 + Math.random() * 0.6;
    this.opacity = 0.3 + Math.random() * 0.4;
    this.wobble = Math.random() * 1000;
  }

  update(time) {
    this.y += this.speed;
    this.x += Math.sin(time * 0.001 + this.wobble) * 0.2;

    if (this.y > height * 0.95) {
      createSplash(this.x, height * 0.95);
      this.reset();
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.scale(this.size / 20, this.size / 20);
    ctx.globalAlpha = this.opacity;

    const gradient = ctx.createRadialGradient(0, 0, 2, 0, 0, 20);
    gradient.addColorStop(0, "rgba(255,120,160,0.9)");
    gradient.addColorStop(1, "rgba(255,60,120,0.6)");
    ctx.fillStyle = gradient;

    ctx.beginPath();
    ctx.moveTo(0, 6);
    ctx.bezierCurveTo(0, -4, -10, -4, -10, 6);
    ctx.bezierCurveTo(-10, 14, 0, 18, 0, 22);
    ctx.bezierCurveTo(0, 18, 10, 14, 10, 6);
    ctx.bezierCurveTo(10, -4, 0, -4, 0, 6);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }
}

class Droplet {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 1 + Math.random() * 2;
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = -Math.random() * 2;
    this.life = 1;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.05;
    this.life -= 0.03;
  }

  draw() {
    ctx.save();
    ctx.globalAlpha = this.life;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,120,160,0.8)";
    ctx.fill();
    ctx.restore();
  }
}

function createSplash(x, y) {
  for (let i = 0; i < 4; i++) {
    droplets.push(new Droplet(x, y));
  }
}

for (let i = 0; i < 70; i++) {
  hearts.push(new Heart());
}

function animate(time) {
  ctx.clearRect(0, 0, width, height);

  hearts.forEach(h => {
    h.update(time);
    h.draw();
  });

  droplets.forEach((d, i) => {
    d.update();
    d.draw();
    if (d.life <= 0) droplets.splice(i, 1);
  });

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
</script>

</body>
</html>
